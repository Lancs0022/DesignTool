On nous a donné un projet où l'on doit créer un logiciel de design qui pourra générer des plan de maisons en 2D. Pour le moment je vais me focaliser sur les éléments graphiques de bases à implémenter.
Voici quelques classes qu'il faut considérer. 

- Plan : qui sera l'élément centrale qui est un JPanel qui contiendra les dessins en question. Ce JPanel peut s'étendre très loin et ayant une grande surface accessible en avec un scroll. mieux au fur et à mesure qu'on s'écarte de la position 0.0, le scroll commence à apparaître et à devenir plus petit. Et au contraire si on se rapproche de la position initiale et qu'il n'y a aucun dessin, en bas le scroll diminue.

- Dessin : qui est un classe qui contiendra une collection de classe Figure 

- Figure : Je crée la classe Figure pour vecteur et points c'est ici qu'on va definir la méthode dessiner que tout les autres classes filles auront. Elle est abstraite et est inclus dans la classe Dessin.

- Geometrie : une classe abstraite mais inclus dans la classe dessin et qui possède une collection de points. Elle hérite de la classe figure.

- Point : qui est une classe qui represente un point d'abscice x et y. On va considérer il hérite de Figure car il peut se dessiner aussi eventuellement.

- Vecteur : qui est une classe qui represente un vecteur de 2 Points et hérite de Figure car il peut se dessiner aussi eventuellement. 

- Polygone : qui possède la particularité d'avoir une collection de vecteurs et hérite de Geometrie et possédant les classes filles suivants. C'est une classe abstraite.

    - Quadrilatère
        - Rectangle 
            - Parallelogramme
        (- Trapèze) Pas indispensable
        (- Losange) Pas indispensable
    - Triangle

(Note : On ne considèrera pas la logique selon laquelle : Tout les figures linéaires sont des Polygones. Je les ai mis sous FigureLineaire car ils seront dessinés de façon différents )

- FigureCirculaire : qui a pour classe fille Arc et Cercle et qui possède un attribut angle en degré dont la classe mère est géométrie. C'est une classe abstraite. Un cercle a quelques segments aussi mais pas aussi nombreux et pas necessairement ordonnée comme ceux des FigureLineaire. On va juste dire qu'un FigureCirculaire possède un vecteur qui est son rayon et que ce rayon est affiché ou non.


La classe Geometrie contiendra une méthode dessiner qui est abstraite et qui dépendra de comment chaque classe fille sera dessiné. 
Je vais faire très simple : Pour dessiner des Polygones il suffit de lui tracer ses vecteurs. Pour le Polygone, le constructeur prend en paramètre plusieurs points en nombre indéterminé et enregistre ça dans la liste de points de la classe. Automatiquement, la liste des vecteurs du Polygone est déterminé comme ci-après : Le point n et le point n+1 de la liste de points forme un Vecteur on enregistre ça dans la liste de vecteurs de la classe pour plus tard. J'insite bien sur cette liste de vecteur car après je prévois un intelligence artificielle qui déterminera si 2 chambres d'une maison sont connecté en se référant à leurs vecteurs. 
les classes qui dérivent du polygone seront construit presque pareil. sauf pour les formes particuliers comme les classes filles d'un Quadrilatère qui devront se construire avec des points et des vecteurs aussi mais il faut que les vecteurs 1 & 3 et 2 & 4 sont alignés et orthogonaux pour un Rectangle et juste alignés pour un Parallelogramme.
(Je vais peut-être être amené à couper des vecteurs en 2 parties comme ceci : on place 2 points quelque part sur le vecteur et on efface la ligne dessiné sur le vecteur formé par ces 2 lignes mais ce n'est qu'un détail pas important pour le moment). 

Pour les cerles ils doivent recevoir le rayon (est un vecteur) et l'angle en paramètre. 

Pour les demi-cercles c'est un peut compliqué il faut 2 angles pour marquer la partie visible du cercle et 2 vecteur rayon aux extremités. Les demi-cercles et les cercles ont des options qui leurs permettent de cacher ou non ces vecteurs rayons. 

Quand au moyen de les dessiner(La méthode dessiner()), elle prendra un Graphics g ou un Graphics2D pourquoi pas en paramètre. De ce fait tous les Figures doivent avoir un attribut du même type pour stocker comment ils vont être dessiné. 

Pour un point ça sera un ovale circulaire et non creux
Pour un vecteur une ligne
Pour les classes qui utilisent des vecteurs il faut dessiner chaque vecteurs dans sa collection

J'ai d'autres spécificités pour les éléments géométriques. Les Polygones peuvent ajouter, supprimer, ou modifier n'importe lequel de ses points. Ce qui a pour conséquence de reconstruire la collection de vecteur en consequence et la reconstitution de dessin généré par dessiner(). Je pense que mes classes sont assez robuste pour supporter ajout, suppression et modification avec toutes les mésures qui on été prises.


Je crois que ça sera tout pour les dessins et la géometrie maintenant passons à ce qu'adviendra du plan.

J'aime bien ce modèle de plan infini que tu m'as proposé dans un autre discussion :

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;

public class DrawingApp extends JFrame {
    private DrawingPanel drawingPanel;

    public DrawingApp() {
        drawingPanel = new DrawingPanel();
        JScrollPane scrollPane = new JScrollPane(drawingPanel);
        getContentPane().add(scrollPane, BorderLayout.CENTER);

        setTitle("Drawing App");
        setSize(800, 600);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            DrawingApp app = new DrawingApp();
            app.setVisible(true);
        });
    }

    class DrawingPanel extends JPanel {
        private ArrayList<Point> points;

        public DrawingPanel() {
            points = new ArrayList<>();
            setPreferredSize(new Dimension(800, 600));
            addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    points.add(e.getPoint());
                    revalidate();
                    repaint();
                }
            });
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            for (Point point : points) {
                g.fillOval(point.x, point.y, 5, 5);
            }
        }

        @Override
        public Dimension getPreferredSize() {
            Dimension size = super.getPreferredSize();
            for (Point point : points) {
                size.width = Math.max(size.width, point.x + 20);
                size.height = Math.max(size.height, point.y + 20);
            }
            return size;
        }
    }
}

Mais juste le fait qu'il soit extensible et théoriquement infini. Pour les actions on verra plus tard.
Pour ce qui est de la méthode à utiliser pour dessiner les dessins on va utiliser bufferedImage pour plus de souplesse :

import javax.swing.JPanel;
import java.awt.Graphics;
import java.awt.image.BufferedImage;

public class Plan extends JPanel {
    private Dessin dessin;
    private BufferedImage image;

    public Plan() {
        this.dessin = new Dessin();
        this.image = new BufferedImage(800, 600, BufferedImage.TYPE_INT_ARGB);
    }

    public void ajouterDessin(Dessin dessin) {
        this.dessin = dessin;
        redraw();
    }

    private void redraw() {
        Graphics g = image.getGraphics();
        g.clearRect(0, 0, image.getWidth(), image.getHeight());
        dessin.dessiner(g);
        g.dispose();
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.drawImage(image, 0, 0, null);
    }
}

Je ne sais pas si tu pourras générer autant de classe. Au pire on étalera tout ça sur plusieurs prompt


Tout est presque en ordre du côté des dessins. il va maintenant faloir se creser les méninges pour préparer le terrain en vue d'acceuillir les fonctionnalités et les actions reliant MenuNavigation et plan.
Premièrement, Il faut ajouter une collection associatif dans plan pour contenir les paramètres interchangeable par l'appui des boutons depuis MenuNavigation.

Mais d'abord apportons quelques modifications au plan.
Je veux créér une variable pouvant contenir les paramètres du plan. Par exemple le nombre de pixel pour 1 mètre dans le plan, la couleur des éléments à dessiner, le mode de saisie (création, destruction ou modification)... pour le moment je n'ai pas trop d'idées sur les fonctionnalités que je vais mettre en place mais je verrai au fur et à mesure. Mon souci c'est que je ne sais pas quel genre de variable est ce que je vais bien pouvoir utiliser pour ça... un Map ? un objet ? Un simple tableau ? La seule chose que je sais c'est qu'il y aura plusieurs variables clé & valeur. Je tends plutôt vers un objet ne contenant que des attributs publique mais c'est pas pratique d'avoir un objet avec des éléments publics a ce qu'il paraît...

Il me manque encore le plus important dans le projet. Les objets représentant les éléments d'un plan de maison. J'ai encore quelques doutes sur le positionnement de ces nouvelles classes à considérer par rapport au classe Figure et ses filles...
Bon après avoir réfléchi j'ai décidé qu'un élément du plan est une classe fille de la classe Dessin. De cette façon, l'élément du plan pourra être dessiné facilement sur le plan comme étant un Dessin et la structure des classes déjà existantes restent intacte.
Donc ElementDuPlan est une classe qui englobera les classes qui composent le figure d'un plan de maison.
Il manipulera la classe figure pour déterminer comment il va dessiner tel ou tel élément. On pourrait lui donner une méthode howToDraw pour empiler des figures entre eux. Aussi, il y aura deux catégories d'éléments du plan : les conteneurs et les contenus. Un conteneur peut avoir plusieurs contenus et un contenu peut aussi être un conteneur de la façon suivante : Un terrain est un conteneur qui peut contenir plusieurs maisons. Les maisons peuvent contenir des conteneurs de type chambre mais aussi des contenus comme une porte, un éscalier une fenêtre... Il faudrait aussi considérer 2 types de contenus : les contenus qui sont collés sur le bord des conteneurs comme les portes, fenêtres, et les contenus libres qui peuvent être collés ou non comme les éscaliers et objets divers comme les lits...
Qu'est ce que t'en pense ?

Maintenant qu'une bonne partie des choses sont en place place à l'organisation de l'ajout d'objets

On va revenir sur les éléments du plan maintenant. C'est assez complexe de définir l'ordre des éléments avec conteneur et contenu alors j'ai pensé à ceci : des interfaces contenu et conteneur pour pouvoir définir un élément du plan comme étant à la fois conteneur et contenu. Donc les chambres, terrains, maison qui sont des conteneurs seront directement dérivés de leur classe mère ElementDuPlan au même niveau que les portes, fenêtres, escaliers, autres objets libres.

Donc les conteneurs ont une liste de contenus et on pourra faire du CRUD sur les contenus dans un conteneur. Il y a toujours la classe ManipList.java pour manipuler cette liste. Les conteneurs ont des comportements spéciaux. Ils peuvent vérifier qu'un autre conteneur ou contenu sont collés ou non à eux. Voici les chose à prendre en compte : deux maisons peuvent être collés mais les côtés (Vecteurs de la maison) qui est collé ne sont pas égaux vecteurement parlant. Il faut donc qu'on vérifie si les deux vecteurs sont allignés sur une même droite pour voir s'ils sont allignés. Puisque cette fonctionnalité traite deux vecteurs, on va créér une autre classe dans le package outils qui pourrait aussi être statique et qui s'occupe de faire ce calcul. Donc dans cette classe, pour l'instant, il n'y aura que 2 méthodes : vectSontAlligne(Vecteur v1, Vecteur v2) et vectSontEgaux(Vecteur v1, Vecteur v2). J'envisage de mettre les méthodes pour mesurer les vecteurs dedans aussi. Je ne peux pas mesurer un vecteur individuellement avec l'hierarchie de mes classes mais cette classe spécialisé qui peux faire des traitements pourra accéder à toutes les couches de mes piles de classe. Donc finalement, ajoute une méthode pour mésurer un vecteur dans cette classes de calcul. Il faudra ensuite faire les mésures au niveau de Plan car c'est lui qui a pixelParMetre qui est l'unité de mesure.

Finalement, 2 contenus peuvent aussi être accollés... alors que faire ? Et, remarque, pixelParMetre est un int. Fais aussi des commentaires sur comment je pourrais faire et si mes logiques sont bonnes 

//--------
Pour répondre à votre question sur l'utilisation de classes vs. interfaces pour les contenus et les conteneurs, voici une analyse détaillée :
Classes vs. Interfaces

    Interfaces :
        Avantages :
            Flexibilité : Permet à différentes classes de différentes hiérarchies d'implémenter les mêmes comportements.
            Polymorphisme : Facilite l'utilisation du polymorphisme, permettant de traiter des objets de différentes classes de manière uniforme.
        Inconvénients :
            Implémentation obligatoire : Toutes les classes implémentant l'interface doivent fournir une implémentation de ses méthodes, ce qui peut entraîner du code répétitif.
            Pas de stockage d'état : Les interfaces ne peuvent pas stocker d'état, ce qui nécessite souvent des classes supplémentaires pour gérer l'état.

    Classes :
        Avantages :
            Encapsulation : Permet de regrouper l'état et le comportement.
            Héritage : Facilite la réutilisation du code via l'héritage.
        Inconvénients :
            Rigidité : Plus rigide que les interfaces en termes de hiérarchie de classe, ce qui peut limiter la flexibilité.

Adaptation à vos exigences

Pour respecter vos exigences de gestion des contenus et des conteneurs, voici comment vous pouvez structurer vos classes :

    Contenu (interface) :
        Déclarez les méthodes de base que tous les contenus doivent implémenter.

    Conteneur (interface) :
        Extendez l'interface Contenu et ajoutez des méthodes spécifiques aux conteneurs (comme la gestion des contenus internes).

    Classes concrètes :
        Implémentez les interfaces Contenu et Conteneur dans des classes concrètes qui encapsulent l'état et les comportements spécifiques.
-------//

Après ça, il faudrait une méthode qui peut me permettre d'aligner automatiquement un contenu sur un autre. Par exemple : Pour dessiner quelque chose sur le plan, il y a une formulaire qu'on impose à l'utilisateur pour savoir ce qu'il veut pour sa maison. Une maison avec 2 pièces et un salon par exemple donc il y a 3 conteneurs pour les chambres et le salon. Il y aura une petite intelligence artificielle qui se chargera d'aligner les 3 chambres selon des dispositions déjà définis. Cet intelligence artificielle devra donc pouvoir savoir prendre le vecteur d'un conteneur et le copier sur un autre pour avoir 2 pièces collés. Il faudrait dans ce cas que l'intelligence puisse créér une polygone personnalisé en spécifiant que la prochaine pièce doit passer après le polygone courant et dans un certain sens. Un autre constructeur devrait donc être requis pour Polygone afin qu'il puisse se dessiner à côté de la polygone courante. Mais le problème dans ce cas c'est que ça doit être à cette classe intelligente d'étudier tout ça et de donner une polygone accollé à un Polygone donné. En réalité la logique pour savoir si deux Composants sont collés ou non devrait se trouver sur cette classe je crois non ? Comme ça il respecte bien son rôle de manipulateur d'objet... Je ne veux pas vraiment d'implémentation ici. Je ne fais que développer une idée et il faut que tu me conseilles sur le meilleur moyen d'implémenter tout ça. Si on reprend où est ce qu'il faut ajouter cet intelligence, il faudrait l'ajouter dans le plan et, soit il est un objet de plan, dans ce cas on stock temporairement les dessins dans un attribut local de la classe intelligente pour les copier au plan ensuite, soit il englobe la classe Plan et la classe formulaire qui envoies les ordres de contruction et il pourra directement écrire dans le plan. J'aimerais cependant avoir des thread différents pour les classes qui envoient des ordres de construction et le Plan car le plan a beaucoup de travail à faire. Il doit notamment se redessiner à la moindre modification et écouter des evenements de la souris et aussi de la barre d'outil que je ferrai plus tard

Pour le toolBar, voici ce qu'il faut y ajouter :
- Un bouton avec un icone de souris pour la selection
    - Lorsque l'input mode est reglé sur selection, quand on clique sur le bord d'un conteneur, Les points sur les bords du conteneur deviennent des figures de type Point. Les points seront plus grosses pour pouvoir les manipuler facilement. 
    Quand on clique sur cet icone de selection, ça modifie l'attribut ParametresPlan.input en "select". Le comportement du listener se transforme comme suit : 
        - D'abord on active l'écoute de la souris. Au survol de la souris sur le vecteur d'un dessin, l'icone de la souris se change en main. On augmente la largeur cliquable du vecteur de quelques pixels pour permettre à l'utilisateur de ne pas galérer à selectionner 1 pixel de large de vecteur. Quand on clique près d'un vecteur, ça localise son objet d'origine c'est à dire : le dessin qui contient ce vecteur. On priorise les conteneurs du plus haut degré s'il y a conflit de vecteurs entre un conteneur et un contenu. Si c'est un conflit entre 2 conteneurs ou contenus du même niveau alors c'est le premier trouvé qui sera selectionné. Quand on clique sur un vecteur donc on selectionne son objet parent. Une fois qu'un objet est selectionné, on le sort de la liste ou bien on mémorise son index pour le trouver plus tard et il faut ajouter mettre dans ParametresPlan un attribut objetSelectionne qui est de type dessin et qui a l'objet actuellement selectionné (dessin)
        Lorsqu'on clic sur aucun objet alors objetSelectionne deviens vide.
        Un objet selectionné on affiche les points sur les bords de l'objetSelectionne. 
        1 - Lors d'un clic de la souris sur les points grossis sur les bords, on déplace le point suivant la position de la souris jusqu'à ce qu'on relache la souris. Lors du relache, l'objet est toujours selectionné.
        2 - Lors d'un clic de la souris sur l'une des points grossis sur les bords, on déplace les 2 point adjacents à ce point pour faire un aggrandissement de l'objet suivant la position de la souris jusqu'à ce qu'on relache la souris. Lors du relache, l'objet est toujours selectionné.. On considèrera que tous les objets sont des rectangles car le traitement du comportement d'un Polygone est trop compliqué.
        Si on tente de superposer deux ElementDuPlan de la même type ex un terrain qui se superpose à un terrain ou une porte qui se superpose avec une porte alors ont génère une erreur.

        - Un autre comportement du mode selection est la manière dont un contenu bouge à l'intérieur d'un conteneur. Tout contenus peut être accollés au bord mais certains doivent être collés sinon ça ne marche pas. Notamment les pièces d'une chambre qui doit avoir un vecteur collé au bord de la maison.

        - Les vecteurs présents dans un conteneurs doivent avoir une sorte de longueur restant en avant et à l'arrière. Par exemple on place une maison Collé au vecteur au nord du terrain et dont le milieu de leurs cotés nords correspondent. Forcément dans ce cas puisque la taille du conteneur est toujours supérieur à celui du contenu, si on considère que A et B sont les 2 points du vecteur nord du terrain et que C et D accollé au vect AB, alors AC et BD sont les vecteurs qui sont toujours libres sur le vecteur sup du terrain et on fait pareil sur chaque face.
        On peut appliquer la même règle pour les conteneurs de même rang.

        ->* Il me faut un algorithme qui détecte si 2 elements de même niveau se superposent ou non §

- Du coup, quoi mettre comme autre bouton ?
- Ajouter Terrain,
- Ajouter Maison,
- Ajouter Piece,
- Ajouter Porte,
- Ajouter Fenetre,
    - Lorsqu'on utilise ces boutons d'ajouts, ça ouvre une petite fenêtre qui contient que des formulaires sur la façon dont il faudra ajouter ces éléments
    - Si la longueur et largeur du contenu dépasse celle du conteneur alors la génération est impossible alors on abandonne le dessin 
    - On positionne une maison au milieu d'un terrain par défaut. Pour se faire, le milieu de la longueur et largeur du terrain doit être aussi celui de la maison. Il faut encore penser à comment faire.
        - Pour le terrain il faut specifier sa taille longeur et largeur.
        - Pour la maison, on demande aussi sa longeur et largeur et on a une liste déroulante de terrains pour déterminer quel terrain contiendra la maison
        - Pour une pièce, on demande quel maison de quel terrain il faut la mettre. 
        - Pour une porte et une fenêtre, on peut la mettre soit sur une maison, soit sur une pièce et elles y sont accollés au niveau des murs uniquement.

    * Problème comment faire pour les objets libres contenus qui ne seront pas collés à quoi que ce soit ?
    -> On interdis de les déplacer librement et à la place on va dire qu'on peut leurs changer de pièce.

- Un bouton pour supprimer l'élément selectionné qui supprime le dessin selectionné. Du moins, on pourrait imaginer une liste fait pour stocker les Dessins effacés. On l'efface de la liste dessins et on le fait entrer dans la liste dessinsEfface.

Pour ce qui en est de la classe formulaires qui contiendra comment on ajoute les éléments sur le plan voici comment elle se comportera. Tout d'abord, elle n'ajoute pas directement d'élements à proprement parler. En faite, elle crée les spécifications indiqué par l'utilisateur et la transmet à une autre classe Intelligente qui se chargera d'analyser les spécifications demandé et les execute si ces spécifications sont correctes.
Et donc pour ce qui l'en est de cette fenêtre de formulaire, il aura des genre de sets. Le set 1 est pour ajouter les champs pour entrer les specs d'un terrain, set2 pour les champs d'ajout d'une maison, set3 pour les champs d'ajout d'une piece, set4 pour les champs d'ajout d'une porte ou d'une fenêtre.
    - Pour un terrain :
        - Nom du terrain, (Terrain + chiffre incrémenté par défaut)
        - Longuer du terrain avec la largeur
    - Pour une maison :
        - Le terrain qui acceuillera la maison (Une liste déroulante des noms de terrains déjà existants)
        - Nom de la maison, (Maison + chiffre incrémenté par défaut)
        - Longuer de la maison avec la largeur
    - Pour une piece :
        - La maison qui acceuille la pièce.
        - Le nom de la piece (Soit on séléctionne parmis les noms prédéfinis, soit on l'entre manuellement. Par défaut elle vaut chambre + chiffre incrémenté)
        - La longeur et la largeur de la piece.
Pour ce qui est de la méthode d'envoi de données je ne sais pas trop comment faire mais est ce que la formation d'un fichier xml pour se faire pourrait être envisageable ?

La classe SuperDrawer est la classe qui se charge de dessiner des dessins selon les ordres qui lui ont été envoyé. 
- Pour ce qui en est de cet ordre à envoyer c'est pas encore très claire. En effet, il faut trouver comment les données envoyé par le formulaire va être 

Si tu as bien remarqué le contenu de view, enfaite selon les boutons appuyés dans parmis les bouton de la class toolbar dans mon view, si on appuie sur le bouton Terrain par exemple, on affiche la formulaire pour entrer un terrain. Une fois que la formulaire est remplie, elle est envoyé à la classe SuperDrawer qui s'occupe de dessiner le tout et de le stocker dans son attribut Liste<Dessin> en attente d'envoi. Il peut générer des erreurs si la construction ne respecte pas certains contraintes. Le plan a une méthode synchronisé qui ajoute des Dessins depuis une liste<Dessins> à sa liste actuelle et dessine tout ça. On pourrait imaginer rassembler toutes ces classes dans une classe à créér dans le package controleur qui les manipule tous et ajoute des actions.

Bon... cette classe pour dessiner des arcs ne marche décidément pas...
Pour se faire alors finalement on va faire ceci pour dessiner un arc : 

Pour les spécifications, On va revenir sur l'ancienne version avec private void enregistrerSpecifications() {
        String nom = nomField.getText();
        String longueur = longueurField.getText();
        String largeur = largeurField.getText();
        String parent = comboBox != null ? comboBox.getSelectedItem().toString() : null;

        xmlSpecs = "<specifications>\n" +
                "    <nom>" + nom + "</nom>\n" +
                "    <longueur>" + longueur + "</longueur>\n" +
                "    <largeur>" + largeur + "</largeur>\n" +
                (parent != null ? "    <parent>" + parent + "</parent>\n" : "") +
                "</specifications>";
    } Mais il va y avoir plus de paramètres à prendre en compte...
Tout d'abord il faut verifier qu'est ce qu'on va construire ? Il y a déjà plusieurs choix possibles :
- Terrain
    - Maison
        - Piece

- Objets libres qui peuvent être soit dans un terrain soit dans une piece.
Tous possède les paramètres suivants :
- Un nom qui est unique
- Un Point de départ avec un x et y
- Un largeur
- Un longueur

Maison et terrain ont des parents qu'on identifie par leurs noms

J'ai réfléchi et finalement je vais faire une refonte de la classe formulaire. Je ne vais plus m'embêter à traiter du xml pour l'instant. On va du coup changer son nom en Constructeur et les données qui sont envoyés via submit sont directement traités par lui même. On créera directement des objets correspondants (Objets, Terrains, Maison, Pieces, etc) avec des dimensions convenables. Je vais également effacer la classe Contenu et Conteneur car c'est très lourd à mettre en place et ça ne resoud même pas entièrement les problèmes qu'il y a. A la place, on va tout mettre dans la classe ElementDuPlan. Donc voici la classe ElementDuPlan pour le moment :

package dessinables.elementsplan;

import java.awt.Graphics;

import dessinables.Dessin;
import dessinables.geometrie.Figure;
import dessinables.geometrie.Point;
import dessinables.geometrie.RectangleEpais;

public abstract class ElementDuPlan extends Dessin{
    protected double largeur, hauteur;
    protected Point ptDepart;
    protected String nom;
    protected float epaisseur;
    protected ElementDuPlan parent;

    public ElementDuPlan(Point pointDepart, double largeur, double hauteur, String nom, ElementDuPlan parent) {
        this.parent = parent;
        this.largeur = largeur;
        this.hauteur = hauteur;
        this.nom = nom;
        this.ptDepart = pointDepart;
        this.epaisseur = 5.0f;
        
        this.getFigures().add(new RectangleEpais(getPtDepart(), (int) largeur, (int) hauteur, this.epaisseur));
    }

    public ElementDuPlan(Point pointDepart, double largeur, double hauteur, String nom) {
        this.parent = null;
        this.largeur = largeur;
        this.hauteur = hauteur;
        this.nom = nom;
        this.ptDepart = pointDepart;
        this.epaisseur = 5.0f;

        this.getFigures().add(new RectangleEpais(getPtDepart(), (int) largeur, (int) hauteur, this.epaisseur));
    }

    public double getLargeur() {
        return largeur;
    }

    public void setLargeur(double largeur) {
        this.largeur = largeur;
    }

    public double getHauteur() {
        return hauteur;
    }

    public void setHauteur(double hauteur) {
        this.hauteur = hauteur;
    }

    public Point getPtDepart() {
        return ptDepart;
    }

    public void setPtDepart(Point ptDepart) {
        this.ptDepart = ptDepart;
    }

    public String getNom() {
        return nom;
    }

    public void setNom(String nom) {
        this.nom = nom;
    }

    public float getEpaisseur() {
        return epaisseur;
    }

    public void setEpaisseur(float epaisseur) {
        this.epaisseur = epaisseur;
    }

    public void dessiner(Graphics g) {
        for (Figure figure : figures) {
            figure.dessiner(g);
        }
    }
}

En ce qui concerne le deuxième constructeur de RectangleEpais, je crois que tout est bon. ce que je fais dans le deuxième constructeur c'est de construire un rectangle à l'aide de sa largeur, de sa hauteur et du point de début qui sera le point le plus à haut et à gauche. La largeur c'est en faite le segment horizontal du rectangle et hauteur la verticale. Les 4 points du rectangle sont ainsi déterminé automatiquement. C'est très important pour la suite du projet... notamment pour savoir si deux rectangles ne se chevauchent pas, on détermine un intervale de points (p1 et p3) dans ce cas ci qui délimite la zone d'un rectangle déjà défini mais je me demande encore comment je vais faire ça. Il y a les classes suivants comme suite de tout ce qu'on a déjà vu

Maintenant répare la classe drawer : package controleurs;

import dessinables.Dessin;
import dessinables.elementsplan.ElementDuPlan;
import dessinables.elementsplan.Maison;
import dessinables.elementsplan.Piece;
import dessinables.elementsplan.conteneur.Terrain;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.List;

public class Drawer implements Runnable {
    private JFrame frame;
    private JPanel panel;
    private JComboBox<String> comboBox;
    private JTextField nomField;
    private JTextField xField;
    private JTextField yField;
    private JTextField longueurField;
    private JTextField largeurField;
    private JButton submitButton;
    private String currentType;
    private ActionListener submitAction;

    public Drawer() {
        initializeForm();
    }

    @Override
    public void run() {
        frame.setVisible(true);
    }

    private void initializeForm() {
        frame = new JFrame("Constructeur");
        panel = new JPanel(new GridLayout(7, 2));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(300, 250);

        nomField = new JTextField();
        xField = new JTextField();
        yField = new JTextField();
        longueurField = new JTextField();
        largeurField = new JTextField();
        submitButton = new JButton("Soumettre");

        frame.add(panel);

        submitButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (submitAction != null) {
                    submitAction.actionPerformed(e);
                }
            }
        });
    }

    public void setTerrainFormFields(List<Dessin> terrainsExistants) {
        panel.removeAll();
        currentType = "terrain";

        panel.add(new JLabel("Nom du terrain:"));
        nomField.setText("Terrain " + (terrainsExistants.size() + 1));
        panel.add(nomField);

        addCommonFields();

        panel.add(submitButton);

        frame.revalidate();
        frame.repaint();
    }

    public void setMaisonFormFields(List<Dessin> terrainsExistants, List<Dessin> maisonsExistantes) {
        panel.removeAll();
        currentType = "maison";

        panel.add(new JLabel("Terrain:"));
        String[] terrains = new String[terrainsExistants.size()];
        for (int i = 0; i < terrainsExistants.size(); i++) {
            terrains[i] = ((ElementDuPlan) terrainsExistants.get(i)).getNom();
        }
        comboBox = new JComboBox<>(terrains);
        panel.add(comboBox);

        panel.add(new JLabel("Nom de la maison:"));
        nomField.setText("Maison " + (maisonsExistantes.size() + 1));
        panel.add(nomField);

        addCommonFields();

        panel.add(submitButton);

        frame.revalidate();
        frame.repaint();
    }

    public void setPieceFormFields(List<Dessin> maisonsExistantes) {
        panel.removeAll();
        currentType = "piece";

        panel.add(new JLabel("Maison:"));
        String[] maisons = new String[maisonsExistantes.size()];
        for (int i = 0; i < maisonsExistantes.size(); i++) {
            maisons[i] = ((ElementDuPlan) maisonsExistantes.get(i)).getNom();
        }
        comboBox = new JComboBox<>(maisons);
        panel.add(comboBox);

        panel.add(new JLabel("Nom de la pièce:"));
        nomField.setText("Chambre " + (maisonsExistantes.size() + 1));
        panel.add(nomField);

        addCommonFields();

        panel.add(submitButton);

        frame.revalidate();
        frame.repaint();
    }

    private void addCommonFields() {
        panel.add(new JLabel("X:"));
        panel.add(xField);
        panel.add(new JLabel("Y:"));
        panel.add(yField);
        panel.add(new JLabel("Longueur:"));
        panel.add(longueurField);
        panel.add(new JLabel("Largeur:"));
        panel.add(largeurField);
    }

    public void setSubmitAction(ActionListener submitAction) {
        this.submitAction = submitAction;
    }

    // Méthodes pour créer les objets correspondants directement
    public ElementDuPlan createElement() {
        String nom = nomField.getText();
        int x = Integer.parseInt(xField.getText());
        int y = Integer.parseInt(yField.getText());
        int longueur = Integer.parseInt(longueurField.getText());
        int largeur = Integer.parseInt(largeurField.getText());

        switch (currentType) {
            case "terrain":
                return new Terrain(nom, x, y, longueur, largeur);
            case "maison":
                String terrainParent = comboBox.getSelectedItem().toString();
                return new Maison(nom, x, y, longueur, largeur, terrainParent);
            case "piece":
                String maisonParent = comboBox.getSelectedItem().toString();
                return new Piece(nom, x, y, longueur, largeur, maisonParent);
            default:
                return null;
        }
    }
}
Oui je l'ai renommé comme ça. Ce que tu as mis comme paramètres du constructeur ici ne correspond pas à ce qu'il faut. On va également ajouter des contraintes à chaque construction. Tout d'abord le point de départ du terrain est fixé sur (100, 100) on va dire. Puis on regarde si il n'y a pas déjà objet plan qui se trouve là. S'il y a déjà quelque chose la où on veut mettre le terrain alors on choisis de déplacer le point de début en dehors de celui qui se trouve déjà sur celui choisi. On essaie de se décaler sur la gauche pour voir s'il y a déjà quelque chose. sur la nouvelle emplacement on revérifie s'il n'y a pas déjà un terrain et ainsi de suite. Sauf si tu trouves un algorithme plus optimisé pour éviter la superposition. Je pense qu'il est mieux de scanner tous les terrains puis de déterminer chaque intervalle de points de chaque terrain puis on regarde les espaces encore vide o`l'on peut encore poser le terrain avec sa longeur et hauteur de manière à ce qu'elle ne se superpose sur aucun terrain. On ne vérifie que la superposition d'un élément avec un élément du même type de cette manière le terrain et ses composants sont encapsulés. Il faut ensuite reporter la logique sur les autres éléments fils (Maison entre maison) Les éléments fils ne doivent pas dépasser la dimension de celui de leur parent. Pour les Pieces et seulement pour les pièces, une contrainte s'ajoute les pieces doivent toujours être collés aux bords de la maison, mais deux pieces ne doivent pas se superposer. Quand aux portes et aux fenêtres, eux doivent toujours être collé sur une pièce 

La création des éléments du plan certes fonctionnent bien mais il y a quelques trucs à rectifier sur la façon dont est construit les éléments du plan. Tout d'abord, les champs x et y du formulaires on va les enlever car Drawer est supposé savoir dessiner les éléments de façon dynamique selon certains contraintes. La position par défaut de la maison dans un terrain est centré au milieu. Donc pour ça, drawer doit devoir prendre le parent de la maison (l'objet terrain qui lui est lié) puis il prends ses dimensions à savoir ses attributs ptDepart, largeur et 1ongueur puis calcule tout ça de la manière suivante : Le point de départ du maison doit se trouver dans le terrain et ou collés aux murs du terrain du moins.

On va se pencher maintenant sur l'ajout des actions de modifications sur ce projet. Lors d'un clic gauche de la souris, on scanne la liste des figures. Pour verifier si le coordonné du souris au clic correspond à celui d'un figure. La detection ne se passe pas que pour les points des rectangles formant l'element, on considère qu'on clique sur un element au niveau du plan quand ses vecteurs sont cliqués. Si il y a conflit entre la selection de 2 objets : si c'est entre un conteneur et son contenu alors c'est le contenu qui sera selectionné par le clic. Si c'est entre 2 elements de même nature alors celui alors on choisis de modifier le dernier créé entre ces 2 la. Au prochain clic l'ancienne selection est abandonné. Lorsqu'un element est selectionné, on peut le redimensionner. On ne prendra en charge que les redimensionnement sur les côtés pour commencer. On ajoute aussi des points observable aux 4 côtés du rectangle formant la figure. Ma classe point se dessine déjà de lui même alors on n'a qu'à dessiner les points composant la figure. package dessinables.geometrie;

import java.awt.Graphics;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

public class Point extends Figure{
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public Point(){
        this.setX(0); this.setY(0);
    }

    public double distance(Point other) {
        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public void translate(int dx, int dy) {
        this.x += dx;
        this.y += dy;
    }

    @Override
    public void dessiner(Graphics g) {
        g.fillOval(x - 2, y - 2, 4, 4); // Un point comme un petit cercle
    }

    @Override
    public String toString() {
        return "(" + x + ", " + y + ")";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Point point = (Point) o;
        return x == point.x && y == point.y;
    }

    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }

    @Override
    public List<Point> getPoints() {
        return Collections.singletonList(this);
    }
}
Tant qu'à faire puisqu'un élément du plan possède une liste de figure et que la classe Point est une exstension de Figure, on va ajouter chaque point composant le rectangle de l'element du plan dans la liste de figure et on introduira un boolen afficherPoints qui choisira si l'on dessinera ou non dans la méthode dessiner.

Encore une fois tu n'as pas respecté ce que j'avais dis précédemment : RectangleEpais contient tout ce qui parle de test booléen pour les contraintes qui nous concerne : Lors d'un redimensionnement, 3 vérifications se font, d'abord, on vérifie si l'élement déplacé ne dépasse pas son conteneur (Son parent), puis on vérifie s'il n'est pas en collision avec un objet soeur de la list<ElementDuPlan> contenus de son parent et enfin on vérifie si le rapetissement n'est pas trop petit au point d'entraîner un collision entre l'élément redimensionné et ses contenus. Seul terrain ne vérifie pas qu'il dépasse son parent vu que logiquement il n'a aucun parent. Cependant il doit tout de même vérifier les 2 autres contraintes. Terrain et Maison vérifient les 3 contraintes car ils sont à la fois contenu et conteneur et d'ailleurs je devrais peut être faire implémenter à maison et à piece les interfaces Contenu et Conteneur à la fois. Je rappelle : 

Bien on va reparler de la classe Drawer et la manière dont les portes et les fenêtres sont placés. On va parler d'un concept assez simple pour un Conteneur : la face de celui ci. Un conteneur ou plus précisément le rectangle épais qui le compose ont 4 faces qui sont le Nord, le sud l'est et l'ouest. Donc pour placer une porte ou une fenêtre il faut choisir une face où placer, la largeur de la porte ou la fenêtre et enfin la pièce qui le contiendra. Par défaut, on choisira de placer la porte au milieu d'une face. On demande aussi combien de porte ou de fenêtre on veux pour une face. La porte et la fenêtre sera un peu différent des autres éléments car au lieu d'avoir une rectangle pour les représenter, on va avoir un simple drawline avec une épaisseur.

Je rejette cette idée il faudrait tout au plus des méthodes génériques mais pas toute la classe. On peut n'avoir que les méthodes de générique n'est ce pas ? Déjà, Les setFormFields peuvent normalement être générique. Create elements et gererElements aussi de rigueur. De base je crois qu'on aura pas besoin de tant de généricité c'est juste que je gère mal la polymorphisme de mes classes. Bon il va faloir que tu factorises la méthode genererElements maintenant et on va faire plus explicite comme nom : genererPorteOuFenetres. Il faudrait peut être une interface spéciale pour les portes et les fenêtres non ?